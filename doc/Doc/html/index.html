<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Memo: overwiew and usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Memo: overwiew and usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="whats"></a>
What's Memo</h1>
<p>Memo is an open source C++ library that provides data-driven and object-oriented memory management. The classic scenario of dynamic memory allocation consists of a program requesting randomly dynamic storage to a black-box allocator that implements a set of malloc/realloc/free functions, and that doesn't know and can't predict anything about the requests of the program. Memo adds a layer between the allocator and the program, and allows the program to select the best memory allocation strategy with the best tuning for every part of the program.</p>
<p>In Memo an allocation algorithm is wrapped by a class implementing the interface <a class="el" href="classmemo_1_1_i_allocator.html">memo::IAllocator</a>. Here is some common allocators:</p>
<ul>
<li><a class="el" href="classmemo_1_1_default_allocator.html" title="Implements IAllocator using the C dynamic memory allocation (malloc, realloc and free) This implement...">memo::DefaultAllocator</a>, which wraps the system malloc/free</li>
<li><a class="el" href="classmemo_1_1_debug_allocator.html">memo::DebugAllocator</a>, which decorates another allocator and adds no man's land around memory blocks and initializes memory to help to catch uninitialized variables and dangling pointers</li>
<li><a class="el" href="classmemo_1_1_stat_allocator.html">memo::StatAllocator</a>, which decorates another allocator to keep tracks of: total memory allocated, total block count, and allocation peaks</li>
<li><a class="el" href="classmemo_1_1_tlsf_allocator.html">memo::TlsfAllocator</a>, which wraps the two level segregate allocator written by Matthew Conte (<a href="http://tlsf.baisoku.org">http://tlsf.baisoku.org</a>)</li>
</ul>
<div class="image">
<img src="classmemo_1_1_i_allocator__inherit__graph.png"  alt="Allocator Hierarchy"/>
</div>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<p>Just as one can expect, Memo provides a set of global functions to allocate memory, similar to the ones of the standard C library, and a set of macros to allocate C++ objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * buffer = memo::alloc( buffer_length, buffer_alignment, 0/ *offset* / );</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">memo::free( buffer );</div>
<div class="line"></div>
<div class="line">Dog * bell = MEMO_NEW( Dog, <span class="stringliteral">&quot;Bell&quot;</span> );</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">MEMO_DELETE( bell );</div>
</div><!-- fragment --><p>The allocation requests are redirected to an object implementing the interface IAllocator. But which one is used? Every thread has its own current allocator, that is used to allocate new memory blocks. Anyway, when a realloc or free is requested, the operation is performed by the allocator that allocated the block, regardless or the current allocator of the thread. The memory configuration file can associate a startup allocator to every thread, otherwise the default allocator is assigned.</p>
<p>Memo allows to change the thread's current allocator, but it's not recommended. The best practice is opening contexts on the callstack:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmemo_1_1_static_name.html">memo::StaticName</a> g_graphics( <span class="stringliteral">&quot;graphics&quot;</span> );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> load_archive( <span class="keyword">const</span> <span class="keywordtype">char</span> * i_file_name )</div>
<div class="line">{</div>
<div class="line">    memo::Context context( g_graphics );</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordtype">void</span> * buffer = memo::alloc( buffer_length, buffer_alignment, 0/ *offset* / );</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The context label is pushed on the calling thread when the object Context is constructed, and popped when it goes out of scope. Of course, contexts can be nested:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmemo_1_1_static_name.html">memo::StaticName</a> g_zoo( <span class="stringliteral">&quot;zoo&quot;</span> );</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classmemo_1_1_static_name.html">memo::StaticName</a> g_robots( <span class="stringliteral">&quot;robots&quot;</span> );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> load_zoo( <span class="keyword">const</span> <span class="keywordtype">char</span> * i_file_name )</div>
<div class="line">{</div>
<div class="line">    memo::Context context( g_zoo );</div>
<div class="line">    load_archive( i_file_name );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> load_robots( <span class="keyword">const</span> <span class="keywordtype">char</span> * i_file_name )</div>
<div class="line">{</div>
<div class="line">    memo::Context context( g_robots );</div>
<div class="line">    load_archive( i_file_name );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Context objects pushed on the call stack form a context path. The function load_archive, called from load_animals, sets on the calling thread the context with the path "zoo/graphics". If the same function is called from load_robots, the path of the context is "robots/graphics".</p>
<p>The memory configuration file can assign and tune an allocator for:</p>
<ul>
<li>the context "robots", and all its child context<ul>
<li>the context "zoo/graphics"</li>
<li>the context "robots/graphics"</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="overhead"></a>
Space and execution overhead</h1>
<p>If you request memory directly to an <a class="el" href="classmemo_1_1_i_allocator.html">memo::IAllocator</a> object, you don't have any space overhead. Anyway every allocation has a time overhead due to the virtual call. If you use the global function memo::alloc or the macro MEMO_NEW, then memo will add, at the beginning of the memory block, a pointer to the allocator used to allocate. Anyway, you may want to use memo just to analyze the memory usage in the debug builds of your program. In this case you can define, in the release builds, in the header <a class="el" href="memo__externals_8h.html">memo_externals.h</a> the macro MEMO_ONLY_DEFAULT_ALLOCATOR as 1. In this way, memo::alloc and friends will resolve to a static call to malloc and friends.</p>
<h1><a class="anchor" id="pool"></a>
Pools</h1>
<p>Memo supports efficient fixed-size allocations with pools (<a class="el" href="classmemo_1_1_typed_pool.html">memo::TypedPool</a> amd <a class="el" href="classmemo_1_1_untyped_pool.html">memo::UntypedPool</a>). The pool is initialized with a capacity, and can allocate objects up to its capacity. When the pool is full, it uses the default allocator, but this mechanism is transparent for the user. The pool has no space overhead, and does not fragment the memory. You can use the pool directly, or you can enable automatic pooling for type by using the macro MEMO_ENABLE_POOL: </p>
<div class="fragment"><div class="line"><a class="code" href="pool_8h.html#ab84b49d60821c60a699d22912de615d3">MEMO_ENABLE_POOL</a>( MyClass, 2000 );</div>
</div><!-- fragment --><p> This declarations tells memo to redirect every MEMO_NEW and MEMO_DELETE of MyClass to pool whose capacity is by default 2000. You can override this capacity in the memory configuration file.</p>
<h1><a class="anchor" id="lifoallocator"></a>
Data Stack and lifo allocations</h1>
<p>Memo allows to use a thread specific data stack, to perform efficient lifo (last-in, first-out) allocations. The lifo constraint is suited to:</p>
<ul>
<li>blocks allocated when the program starts, and released when the program exits</li>
<li>temporary dynamic storage needed to a function or scope, like in this example:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> required_size = strlen(str1) + strlen(str2) + 1;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">char</span> * buffer = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">char</span> * <span class="keyword">&gt;</span>( memo::lifo_alloc( <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * required_size, <a class="code" href="memo__externals_8h.html#a924d8daa9e11da8f50fd634ebc58b0d1">MEMO_ALIGNMENT_OF</a>(<span class="keywordtype">char</span>), 0, <span class="keyword">nullptr</span> ) );</div>
<div class="line"></div>
<div class="line">strcpy( buffer, str1 );</div>
<div class="line">strcat( buffer, str2 );</div>
<div class="line"></div>
<div class="line">printf( buffer );</div>
<div class="line"></div>
<div class="line">memo::lifo_free( buffer );</div>
</div><!-- fragment --><p>Allocations in the data stack are very fast, do not fragment the memory, and don't waste any space, as the memory blocks are "packed" together one after the other in a single (or in a few) memory buffer. The lifo order must be respected, otherwise the memory gets corrupted. In a debug build, a mismatch is reported with an assert. See <a class="el" href="classmemo_1_1_object_stack.html" title="Class implementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wi...">memo::ObjectStack</a>, <a class="el" href="classmemo_1_1_lifo_allocator.html">memo::LifoAllocator</a> and <a class="el" href="classmemo_1_1_object_lifo_allocator.html" title="Class implementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wi...">memo::ObjectLifoAllocator</a> for details.</p>
<h1><a class="anchor" id="fifoallocator"></a>
Queues and fifo allocations</h1>
<p>Memo provides support for fifo (first-in, first-out) ordered allocations too. This kind of ordering is suited for the producer-consumer problem, allowing dealing with items of variable size and alignment allocated in-place in a single memory buffer. As example of this scenario consider a command queue of a thread, with every command being a struct or class with different data members, that are the parameters of the command. A second and similar use case may be a command buffer for a graphic renderer. See <a class="el" href="classmemo_1_1_fifo_allocator.html">memo::FifoAllocator</a> and <a class="el" href="classmemo_1_1_queue.html">memo::Queue</a> for details.</p>
<h1><a class="anchor" id="corruptiondetector"></a>
Detecting memory corruption</h1>
<p>Memo includes a special allocator to help to find bugs in the code that causes wrong memory access and memory corruption. CorruptionDetectorAllocator can detect:</p>
<ul>
<li>read accesses to memory that was allocated but never written (i.e. uninitialized memory usage)</li>
<li>read or write access to memory outside allocated blocks</li>
</ul>
<p>CorruptionDetectorAllocator runs an external debugger, "memo_debugger.exe", and communicates with it. memo_debugger tracks every read or write access inside the memory managed by CorruptionDetectorAllocator, so the access to this memory is extremely slow. Currently this allocator is defined only for windows, as it uses windows specific APIs. Internally CorruptionDetectorAllocator uses the tlsf allocator implemented by Matthew Conte (<a href="http://tlsf.baisoku.org">http://tlsf.baisoku.org</a>).</p>
<p>When memo_debugger detects an invalid memory read or write operation, it breaks the execution of the program, writes about the error on its console window, and allows the user to choose one if these actions:</p>
<ul>
<li>detaching the target process, to allow another debugger to attach to it</li>
<li>resuming the target process, ignoring the error</li>
<li>quitting, after resuming the target process</li>
<li>saving a dump that can be opened in a compatible debugger, such visual studio or windbg.</li>
<li>dumping the memory content around the address being wrongly accessed</li>
<li>saving or copying all the output of the debugger</li>
</ul>
<p>Here is an example of the output of the debugger:</p>
<pre class="fragment">         *********** ERROR: attempt to write unwritable address 0x00790C9C ***********

        *** STACK TRACE ***
        -&gt;0x0096047A memo::ContextTest::test_CorruptionDetectorAllocator (231)
          0x0095FA95 memo::ContextTest::test (247)
          0x0095F974 memo::test (262)
          0x0094B5A6 main (82)
          0x0098E7FF __tmainCRTStartup (555)
          0x0098E62F mainCRTStartup (371)
          0x75D5ED5C BaseThreadInitThunk (371)
          0x778B37EB RtlInitializeExceptionChain (371)
          0x778B37BE RtlInitializeExceptionChain (371)

        *** SOURCE CODE AROUND 0x0096047A ***
        module: D:\GitHub\mmemo\test\Debug\test.exe
        source file: d:\github\mmemo\memo_test.cpp
           229:             int * array = MEMO_NEW_ARRAY( int, 5 );
           230:             for( int i = 1; i &lt;= 5; i++ )
        -&gt; 231:                 array[i] = i;
           232:             MEMO_DELETE_ARRAY( array );
           233: 

        *** MEMORY CONTENT AROUND 0x00790C9C grouped by 4 byte(s) ***
          0x00790C7C: 0x00790000 - not allocated
          0x00790C80: 0x0045842c - readable/writable
          0x00790C84: 0x00000005 - readable/writable
          0x00790C88: 0x40400000 - writable
          0x00790C8C: 0x00000001 - readable/writable
          0x00790C90: 0x00000002 - readable/writable
          0x00790C94: 0x00000003 - readable/writable
          0x00790C98: 0x00000004 - readable/writable
        -&gt;0x00790C9C: 0x00790c70 - not allocated
          0x00790CA0: 0x000ff359 - not allocated
          0x00790CA4: 0x00790000 - not allocated
          0x00790CA8: 0x00790000 - not allocated
          0x00790CAC: 0x00000000 - not allocated
          0x00790CB0: 0x00000000 - not allocated
          0x00790CB4: 0x00000000 - not allocated
          0x00790CB8: 0x00000000 - not allocated
          0x00790CBC: 0x00000000 - not allocated

        Type a command:
          detach: detach the target process, to allow another debugger to attach to it
          ignore: resume the target process, ignoring the error
          quit: resume the target process, and quit
          minidump [file=test_memo_mini.dmp]: save a minidump
          dump [file=test_memo.dmp]: save a complete dump
          mem [1|2|4|8]: dump memory content around 0x00790C9C
          save [file=test_memo_output.txt]: save all the output of this program
          copy: copy all the output of this program into the clipboard
        &gt;&gt; </pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 30 2014 08:20:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
