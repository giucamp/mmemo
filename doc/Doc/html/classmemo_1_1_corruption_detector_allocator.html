<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CorruptionDetectorAllocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memo</b></li><li class="navelem"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html">CorruptionDetectorAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmemo_1_1_corruption_detector_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CorruptionDetectorAllocator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="corruption__detector__allocator_8h_source.html">corruption_detector_allocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CorruptionDetectorAllocator:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_corruption_detector_allocator__inherit__graph.png" border="0" usemap="#_corruption_detector_allocator_inherit__map" alt="Inheritance graph"/></div>
<map name="_corruption_detector_allocator_inherit__map" id="_corruption_detector_allocator_inherit__map">
<area shape="rect" id="node2" href="classmemo_1_1_i_allocator.html" title="IAllocator" alt="" coords="58,5,133,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CorruptionDetectorAllocator:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_corruption_detector_allocator__coll__graph.png" border="0" usemap="#_corruption_detector_allocator_coll__map" alt="Collaboration graph"/></div>
<map name="_corruption_detector_allocator_coll__map" id="_corruption_detector_allocator_coll__map">
<area shape="rect" id="node2" href="classmemo_1_1_i_allocator.html" title="IAllocator" alt="" coords="58,5,133,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmemo_1_1_corruption_detector_allocator_1_1_config.html">Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a31adafa97455b9ed1afc71d76ecc5250"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a31adafa97455b9ed1afc71d76ecc5250">alloc</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset)</td></tr>
<tr class="separator:a31adafa97455b9ed1afc71d76ecc5250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b506f9f08866cd612df09df5729e15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ae9b506f9f08866cd612df09df5729e15">realloc</a> (void *i_address, size_t i_new_size, size_t i_alignment, size_t i_alignment_offset)</td></tr>
<tr class="separator:ae9b506f9f08866cd612df09df5729e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f79933455057df502c53e84758201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a5b9f79933455057df502c53e84758201">free</a> (void *i_address)</td></tr>
<tr class="separator:a5b9f79933455057df502c53e84758201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4612305ce0bee1f7cdaf8622772e079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">dbg_check</a> (void *i_address)</td></tr>
<tr class="separator:ae4612305ce0bee1f7cdaf8622772e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503133ce3a0f9797d869d418cd6c44e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a503133ce3a0f9797d869d418cd6c44e3">unaligned_alloc</a> (size_t i_size)</td></tr>
<tr class="separator:a503133ce3a0f9797d869d418cd6c44e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6ecb43bdc4d31af49a0761e396c6c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c">unaligned_realloc</a> (void *i_address, size_t i_new_size)</td></tr>
<tr class="separator:a1bb6ecb43bdc4d31af49a0761e396c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad879010ea7f782337c0f46c8425789ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ad879010ea7f782337c0f46c8425789ba">unaligned_free</a> (void *i_address)</td></tr>
<tr class="separator:ad879010ea7f782337c0f46c8425789ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade440d3b38b571e4c3c4a1d654ae78a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">unaligned_dbg_check</a> (void *i_address)</td></tr>
<tr class="separator:aade440d3b38b571e4c3c4a1d654ae78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa008fa6d6cfae377d69e12c146adb98c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">dump_state</a> (<a class="el" href="classmemo_1_1_i_allocator_1_1_state_writer.html">StateWriter</a> &amp;i_state_writer)</td></tr>
<tr class="separator:aa008fa6d6cfae377d69e12c146adb98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmemo_1_1_i_allocator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmemo_1_1_i_allocator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmemo_1_1_i_allocator.html">IAllocator</a></td></tr>
<tr class="memitem:ac67faf58bc98b2a837b75827b155000e inherit pub_methods_classmemo_1_1_i_allocator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#ac67faf58bc98b2a837b75827b155000e">~IAllocator</a> ()</td></tr>
<tr class="separator:ac67faf58bc98b2a837b75827b155000e inherit pub_methods_classmemo_1_1_i_allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe68613d98ba9a392a9ef421a3471bd2"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_corruption_detector_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">type_name</a> ()</td></tr>
<tr class="separator:abe68613d98ba9a392a9ef421a3471bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a special allocator that is able to detect:</p>
<ul>
<li>read accesses to memory that was allocated but never written (i.e. uninitialized memory usage)</li>
<li>read or write access to memory outside allocated blocks</li>
</ul>
<p><a class="el" href="classmemo_1_1_corruption_detector_allocator.html">CorruptionDetectorAllocator</a> runs an external debugger, "memo_debugger.exe", and communicates with it. memo_debugger tracks every read or write access inside the memory managed by <a class="el" href="classmemo_1_1_corruption_detector_allocator.html">CorruptionDetectorAllocator</a>, so the access to this memory is extremely slow. Currently this allocator is defined only for windows, as it uses windows specific APIs. Internally <a class="el" href="classmemo_1_1_corruption_detector_allocator.html">CorruptionDetectorAllocator</a> uses the tlsf allocator implemented by Matthew Conte (<a href="http://tlsf.baisoku.org">http://tlsf.baisoku.org</a>).</p>
<p>When memo_debugger detects an invalid memory read or write operation, it breaks the execution of the program, writes about the error on its console window, and allows the user to choose one if these actions:</p>
<ul>
<li>detaching the target process, to allow another debugger to attach to it</li>
<li>resuming the target process, ignoring the error</li>
<li>quitting, after resuming the target process</li>
<li>saving a dump that can be opened in a compatible debugger, such visual studio or windbg.</li>
<li>dumping the memory content around the address being wrongly accessed</li>
<li>saving or copying all the output of the debugger</li>
</ul>
<p>Here is an example of the output of the debugger:</p>
<pre class="fragment"> *********** ERROR: attempt to write unwritable address 0x00790C9C ***********

*** STACK TRACE ***
-&gt;0x0096047A memo::ContextTest::test_CorruptionDetectorAllocator (231)
  0x0095FA95 memo::ContextTest::test (247)
  0x0095F974 memo::test (262)
  0x0094B5A6 main (82)
  0x0098E7FF __tmainCRTStartup (555)
  0x0098E62F mainCRTStartup (371)
  0x75D5ED5C BaseThreadInitThunk (371)
  0x778B37EB RtlInitializeExceptionChain (371)
  0x778B37BE RtlInitializeExceptionChain (371)

*** SOURCE CODE AROUND 0x0096047A ***
module: D:\GitHub\mmemo\test\Debug\test.exe
source file: d:\github\mmemo\memo_test.cpp
   229:             int * array = MEMO_NEW_ARRAY( int, 5 );
   230:             for( int i = 1; i &lt;= 5; i++ )
-&gt; 231:                 array[i] = i;
   232:             MEMO_DELETE_ARRAY( array );
   233: 

*** MEMORY CONTENT AROUND 0x00790C9C grouped by 4 byte(s) ***
  0x00790C7C: 0x00790000 - not allocated
  0x00790C80: 0x0045842c - readable/writable
  0x00790C84: 0x00000005 - readable/writable
  0x00790C88: 0x40400000 - writable
  0x00790C8C: 0x00000001 - readable/writable
  0x00790C90: 0x00000002 - readable/writable
  0x00790C94: 0x00000003 - readable/writable
  0x00790C98: 0x00000004 - readable/writable
-&gt;0x00790C9C: 0x00790c70 - not allocated
  0x00790CA0: 0x000ff359 - not allocated
  0x00790CA4: 0x00790000 - not allocated
  0x00790CA8: 0x00790000 - not allocated
  0x00790CAC: 0x00000000 - not allocated
  0x00790CB0: 0x00000000 - not allocated
  0x00790CB4: 0x00000000 - not allocated
  0x00790CB8: 0x00000000 - not allocated
  0x00790CBC: 0x00000000 - not allocated

Type a command:
  detach: detach the target process, to allow another debugger to attach to it
  ignore: resume the target process, ignoring the error
  quit: resume the target process, and quit
  minidump [file=test_memo_mini.dmp]: save a minidump
  dump [file=test_memo.dmp]: save a complete dump
  mem [1|2|4|8]: dump memory content around 0x00790C9C
  save [file=test_memo_output.txt]: save all the output of this program
  copy: copy all the output of this program into the clipboard
&gt;&gt; </pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a31adafa97455b9ed1afc71d76ecc5250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocates an aligned memory block. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a502e2c01bb5cb2b3b4cd6f57c626c9c1">IAllocator::alloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from beginning of the block of the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a502e2c01bb5cb2b3b4cd6f57c626c9c1">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ae4612305ce0bee1f7cdaf8622772e079"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dbg_check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#ac5b0f56c8c147c673b88ac51f107df2b">IAllocator::dbg_check</a>. All the consistency checks are performed on the memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to check </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#ac5b0f56c8c147c673b88ac51f107df2b">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="aa008fa6d6cfae377d69e12c146adb98c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dump_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmemo_1_1_i_allocator_1_1_state_writer.html">StateWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>i_state_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes out in a human readable way the state of the allocator </p>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a627cfb25a78006c09db973842404a06b">IAllocator</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_corruption_detector_allocator_aa008fa6d6cfae377d69e12c146adb98c_cgraph.png" border="0" usemap="#classmemo_1_1_corruption_detector_allocator_aa008fa6d6cfae377d69e12c146adb98c_cgraph" alt=""/></div>
<map name="classmemo_1_1_corruption_detector_allocator_aa008fa6d6cfae377d69e12c146adb98c_cgraph" id="classmemo_1_1_corruption_detector_allocator_aa008fa6d6cfae377d69e12c146adb98c_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_i_allocator_1_1_state_writer.html#ae0a7b68f37c9219a7d8f4bc6f6775cc4" title="memo::IAllocator::StateWriter\l::write" alt="" coords="144,5,339,46"/><area shape="rect" id="node3" href="classmemo_1_1_i_allocator_1_1_state_writer.html#af79a38097846b165eb4b06436b727e2f" title="memo::IAllocator::StateWriter\l::write_mem_size" alt="" coords="144,70,339,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5b9f79933455057df502c53e84758201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>deallocates a memory block allocated by alloc or realloc. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a2074f5d80f1f3ca67b9fce58dec57912">IAllocator::free</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a2074f5d80f1f3ca67b9fce58dec57912">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ae9b506f9f08866cd612df09df5729e15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>changes the size of the memory block allocated by alloc, possibly moving it in a new location. Implements <a class="el" href="classmemo_1_1_i_allocator.html#ace08f45e1451933243a499f77fb8d61c">IAllocator::realloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address of the first byte in the block, or nullptr if the reallocation fails </dd></dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#ace08f45e1451933243a499f77fb8d61c">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="abe68613d98ba9a392a9ef421a3471bd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static function returning the name of the allocator class, used to register the type. This name can be used to instantiate this allocator in the configuration file. </p>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a503133ce3a0f9797d869d418cd6c44e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * unaligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocates a new memory block. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a56b7c7e3e00e70d59344247f2d460c7c">IAllocator::unaligned_alloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a56b7c7e3e00e70d59344247f2d460c7c">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="aade440d3b38b571e4c3c4a1d654ae78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unaligned_dbg_check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function performs some integrity check on the block. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a438a0ba99be29dd5334efec6d001b40d">IAllocator::unaligned_dbg_check</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to check </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a438a0ba99be29dd5334efec6d001b40d">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ad879010ea7f782337c0f46c8425789ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unaligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>deallocates a memory block allocated by unaligned_alloc or unaligned_realloc. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a419e6240602d01284e67b38ef6f95911">IAllocator::unaligned_free</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a419e6240602d01284e67b38ef6f95911">IAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a1bb6ecb43bdc4d31af49a0761e396c6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * unaligned_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>changes the size of the memory block allocated by unaligned_alloc. Implements <a class="el" href="classmemo_1_1_i_allocator.html#a202b96480cec2c2b9df48e81159b62fc">IAllocator::unaligned_realloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address of the first byte in the block, or nullptr if the reallocation fails </dd></dl>

<p>Implements <a class="el" href="classmemo_1_1_i_allocator.html#a202b96480cec2c2b9df48e81159b62fc">IAllocator</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/SmartGit/mmemo/allocators/<a class="el" href="corruption__detector__allocator_8h_source.html">corruption_detector_allocator.h</a></li>
<li>D:/SmartGit/mmemo/allocators/corruption_detector_allocator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 30 2014 08:20:38 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
