<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>IAllocator Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memo</b></li><li class="navelem"><a class="el" href="classmemo_1_1_i_allocator.html">IAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="interfacememo_1_1_i_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IAllocator Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for IAllocator:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator__inherit__graph.png" border="0" usemap="#_i_allocator_inherit__map" alt="Inheritance graph"/></div>
<map name="_i_allocator_inherit__map" id="_i_allocator_inherit__map">
<area shape="rect" id="node2" href="classmemo_1_1_corruption_detector_allocator.html" title="CorruptionDetectorAllocator" alt="" coords="5,80,187,107"/><area shape="rect" id="node3" href="classmemo_1_1_decorator_allocator.html" title="DecoratorAllocator" alt="" coords="211,80,340,107"/><area shape="rect" id="node6" href="classmemo_1_1_default_allocator.html" title="Implements IAllocator using the C dynamic memory allocation (malloc, realloc and free) This implement..." alt="" coords="365,80,477,107"/><area shape="rect" id="node7" href="classmemo_1_1_region_allocator.html" title="RegionAllocator" alt="" coords="502,80,615,107"/><area shape="rect" id="node4" href="classmemo_1_1_debug_allocator.html" title="DebugAllocator" alt="" coords="157,155,267,181"/><area shape="rect" id="node5" href="classmemo_1_1_stat_allocator.html" title="StatAllocator" alt="" coords="291,155,388,181"/><area shape="rect" id="node8" href="classmemo_1_1_tlsf_allocator.html" title="TlsfAllocator" alt="" coords="512,155,605,181"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmemo_1_1_i_allocator_1_1_config.html">Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator_1_1_state_writer.html">StateWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a502e2c01bb5cb2b3b4cd6f57c626c9c1"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a502e2c01bb5cb2b3b4cd6f57c626c9c1">alloc</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset)=0</td></tr>
<tr class="separator:a502e2c01bb5cb2b3b4cd6f57c626c9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace08f45e1451933243a499f77fb8d61c"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#ace08f45e1451933243a499f77fb8d61c">realloc</a> (void *i_address, size_t i_new_size, size_t i_alignment, size_t i_alignment_offset)=0</td></tr>
<tr class="separator:ace08f45e1451933243a499f77fb8d61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2074f5d80f1f3ca67b9fce58dec57912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a2074f5d80f1f3ca67b9fce58dec57912">free</a> (void *i_address)=0</td></tr>
<tr class="separator:a2074f5d80f1f3ca67b9fce58dec57912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b0f56c8c147c673b88ac51f107df2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#ac5b0f56c8c147c673b88ac51f107df2b">dbg_check</a> (void *i_address)=0</td></tr>
<tr class="separator:ac5b0f56c8c147c673b88ac51f107df2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b7c7e3e00e70d59344247f2d460c7c"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a56b7c7e3e00e70d59344247f2d460c7c">unaligned_alloc</a> (size_t i_size)=0</td></tr>
<tr class="separator:a56b7c7e3e00e70d59344247f2d460c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b96480cec2c2b9df48e81159b62fc"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a202b96480cec2c2b9df48e81159b62fc">unaligned_realloc</a> (void *i_address, size_t i_new_size)=0</td></tr>
<tr class="separator:a202b96480cec2c2b9df48e81159b62fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419e6240602d01284e67b38ef6f95911"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a419e6240602d01284e67b38ef6f95911">unaligned_free</a> (void *i_address)=0</td></tr>
<tr class="separator:a419e6240602d01284e67b38ef6f95911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438a0ba99be29dd5334efec6d001b40d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a438a0ba99be29dd5334efec6d001b40d">unaligned_dbg_check</a> (void *i_address)=0</td></tr>
<tr class="separator:a438a0ba99be29dd5334efec6d001b40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67faf58bc98b2a837b75827b155000e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#ac67faf58bc98b2a837b75827b155000e">~IAllocator</a> ()</td></tr>
<tr class="separator:ac67faf58bc98b2a837b75827b155000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627cfb25a78006c09db973842404a06b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#a627cfb25a78006c09db973842404a06b">dump_state</a> (<a class="el" href="classmemo_1_1_i_allocator_1_1_state_writer.html">StateWriter</a> &amp;i_state_writer)=0</td></tr>
<tr class="separator:a627cfb25a78006c09db973842404a06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe68613d98ba9a392a9ef421a3471bd2"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_i_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">type_name</a> ()</td></tr>
<tr class="separator:abe68613d98ba9a392a9ef421a3471bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for classes that provide memory allocation services. Classes implementing this interface provide function to allocate, reallocate and free dynamic memory blocks. Two separate sets of functions are defined, for aligned and unaligned allocations. The two sets are mutually incompatible, and mixing them causes memory corruption. For example, memory allocated with alloc can be deallocated by free, but not by unaligned_free. </p>
<div class="fragment"></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac67faf58bc98b2a837b75827b155000e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classmemo_1_1_i_allocator.html">IAllocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>virtual destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a502e2c01bb5cb2b3b4cd6f57c626c9c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new memory block, respecting the requested alignment with an offset from the beginning of the block. Anyway the first byte of the block is aligned such that it can be used to store any integral or pointer variable. If the allocation fails nullptr is returned. If the request size is zero the return value is a non-null address that points to a zero-sized memory block. The content of the newly allocated block is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from beginning of the block of the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a31adafa97455b9ed1afc71d76ecc5250">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#a31adafa97455b9ed1afc71d76ecc5250">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#a31adafa97455b9ed1afc71d76ecc5250">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#aa0efeca40d5326beeff035039fe5cc36">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#a31adafa97455b9ed1afc71d76ecc5250">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a502e2c01bb5cb2b3b4cd6f57c626c9c1_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a502e2c01bb5cb2b3b4cd6f57c626c9c1_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a502e2c01bb5cb2b3b4cd6f57c626c9c1_icgraph" id="classmemo_1_1_i_allocator_a502e2c01bb5cb2b3b4cd6f57c626c9c1_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#a31adafa97455b9ed1afc71d76ecc5250" title="memo::DebugAllocator\l::alloc" alt="" coords="104,5,259,46"/><area shape="rect" id="node3" href="classmemo_1_1_stat_allocator.html#a31adafa97455b9ed1afc71d76ecc5250" title="allocates an aligned memory block. Implements IAllocator::alloc. The dest allocator is used to perfor..." alt="" coords="111,70,252,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac5b0f56c8c147c673b88ac51f107df2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dbg_check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs some checks on a new memory block allocated by alloc or realloc. The actual checks depend on the allocator and the configuration being compiled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to check </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#ae4612305ce0bee1f7cdaf8622772e079">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_ac5b0f56c8c147c673b88ac51f107df2b_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_ac5b0f56c8c147c673b88ac51f107df2b_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_ac5b0f56c8c147c673b88ac51f107df2b_icgraph" id="classmemo_1_1_i_allocator_ac5b0f56c8c147c673b88ac51f107df2b_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_stat_allocator.html#ae4612305ce0bee1f7cdaf8622772e079" title="Implements IAllocator::dbg_check. Some basic checks is performed on the memory block. " alt="" coords="139,5,280,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a627cfb25a78006c09db973842404a06b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dump_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmemo_1_1_i_allocator_1_1_state_writer.html">StateWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>i_state_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes out in a human readable way the state of the allocator. This method is not for serialization, but should instead print statistics meaningful for the user as a list of property's name-value pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_write_function</td><td>Function to call for every property </td></tr>
    <tr><td class="paramname">i_user_param</td><td>user parameter to be passed to i_write_function </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">DefaultAllocator</a>, <a class="el" href="classmemo_1_1_tlsf_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">TlsfAllocator</a>, <a class="el" href="classmemo_1_1_region_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">RegionAllocator</a>, and <a class="el" href="classmemo_1_1_decorator_allocator.html#aa008fa6d6cfae377d69e12c146adb98c">DecoratorAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a627cfb25a78006c09db973842404a06b_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a627cfb25a78006c09db973842404a06b_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a627cfb25a78006c09db973842404a06b_icgraph" id="classmemo_1_1_i_allocator_a627cfb25a78006c09db973842404a06b_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_decorator_allocator.html#aa008fa6d6cfae377d69e12c146adb98c" title="memo::DecoratorAllocator\l::dump_state" alt="" coords="144,38,317,79"/><area shape="rect" id="node3" href="classmemo_1_1_debug_allocator.html#aa008fa6d6cfae377d69e12c146adb98c" title="memo::DebugAllocator\l::dump_state" alt="" coords="365,5,520,46"/><area shape="rect" id="node4" href="classmemo_1_1_stat_allocator.html#aa008fa6d6cfae377d69e12c146adb98c" title="memo::StatAllocator\l::dump_state" alt="" coords="372,70,513,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2074f5d80f1f3ca67b9fce58dec57912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates a memory block allocated by alloc or realloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a5b9f79933455057df502c53e84758201">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#a5b9f79933455057df502c53e84758201">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#a5b9f79933455057df502c53e84758201">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#a5b9f79933455057df502c53e84758201">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#a5b9f79933455057df502c53e84758201">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a2074f5d80f1f3ca67b9fce58dec57912_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a2074f5d80f1f3ca67b9fce58dec57912_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a2074f5d80f1f3ca67b9fce58dec57912_icgraph" id="classmemo_1_1_i_allocator_a2074f5d80f1f3ca67b9fce58dec57912_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#a5b9f79933455057df502c53e84758201" title="memo::DebugAllocator\l::free" alt="" coords="96,5,251,46"/><area shape="rect" id="node3" href="classmemo_1_1_stat_allocator.html#a5b9f79933455057df502c53e84758201" title="deallocates a memory block allocated by alloc or realloc. Implements IAllocator::free. The dest allocator is used to perform the operation. See DecoratorAllocator. " alt="" coords="103,70,244,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ace08f45e1451933243a499f77fb8d61c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the size of the memory block allocated by alloc, possibly moving it in a new location. If the memory block can be resized, the same address is returned. Otherwise the block is allocated in a new location, and the content is copied to the new location. Then the old block is freed. The content of the memory block is preserved up to the lesser of the new size and the old size, while the content of the newly allocated portion is undefined. If the request size is zero the return value is a non-null address that points to a zero-sized memory block. The alignment and the offset of the alignment of an existing memory block cannot be changed by realloc. If the reallocation fails nullptr is returned, and the memory block is left unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address of the first byte in the block, or nullptr if the reallocation fails </dd></dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ae9b506f9f08866cd612df09df5729e15">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#ae9b506f9f08866cd612df09df5729e15">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#ae9b506f9f08866cd612df09df5729e15">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#a395439b510ef188e61817cae0f28b255">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#ae9b506f9f08866cd612df09df5729e15">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_ace08f45e1451933243a499f77fb8d61c_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_ace08f45e1451933243a499f77fb8d61c_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_ace08f45e1451933243a499f77fb8d61c_icgraph" id="classmemo_1_1_i_allocator_ace08f45e1451933243a499f77fb8d61c_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#ae9b506f9f08866cd612df09df5729e15" title="memo::DebugAllocator\l::realloc" alt="" coords="115,5,269,46"/><area shape="rect" id="node3" href="classmemo_1_1_stat_allocator.html#ae9b506f9f08866cd612df09df5729e15" title="changes the size of the memory block allocated by alloc, possibly moving it in a new location..." alt="" coords="121,70,263,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abe68613d98ba9a392a9ef421a3471bd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static function returning the name of the type, used for example in the configuration file, where a type of allocated must be specified. <a class="el" href="classmemo_1_1_allocator_config_factory.html">AllocatorConfigFactory</a> uses this function to associate a name to the allocator. Every class implementing <a class="el" href="classmemo_1_1_i_allocator.html">IAllocator</a> should define a static function with this name and signature. The returned string should lie in the static storage (a string literal is the best choice). </p>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">DebugAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">DefaultAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">StatAllocator</a>, <a class="el" href="classmemo_1_1_region_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">RegionAllocator</a>, <a class="el" href="classmemo_1_1_tlsf_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">TlsfAllocator</a>, and <a class="el" href="classmemo_1_1_decorator_allocator.html#abe68613d98ba9a392a9ef421a3471bd2">DecoratorAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a56b7c7e3e00e70d59344247f2d460c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* unaligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new memory block. If the allocation fails nullptr is returned. If the request size is zero the return value is a non-null address that points to a zero-sized memory block. The alignment of the newly allocated block allows to use it to store any integral or pointer variable. The content of the newly allocated block is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a503133ce3a0f9797d869d418cd6c44e3">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#a503133ce3a0f9797d869d418cd6c44e3">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#a503133ce3a0f9797d869d418cd6c44e3">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#aa56dbfb1b844d2f82bb6b5582564559e">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#a503133ce3a0f9797d869d418cd6c44e3">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a56b7c7e3e00e70d59344247f2d460c7c_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a56b7c7e3e00e70d59344247f2d460c7c_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a56b7c7e3e00e70d59344247f2d460c7c_icgraph" id="classmemo_1_1_i_allocator_a56b7c7e3e00e70d59344247f2d460c7c_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#a503133ce3a0f9797d869d418cd6c44e3" title="memo::DebugAllocator\l::unaligned_alloc" alt="" coords="167,5,321,46"/><area shape="rect" id="node3" href="classmemo_1_1_region_allocator.html#a1704b88387d1451cecf41537cbb20726" title="memo::RegionAllocator\l::RegionAllocator" alt="" coords="165,70,323,111"/><area shape="rect" id="node4" href="classmemo_1_1_stat_allocator.html#a503133ce3a0f9797d869d418cd6c44e3" title="allocates a new memory block. Implements IAllocator::unaligned_alloc. The dest allocator is used to p..." alt="" coords="173,135,315,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a438a0ba99be29dd5334efec6d001b40d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unaligned_dbg_check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs some checks on a new memory block allocated by unaligned_alloc or unaligned_realloc. The actual checks depend on the allocator and the configuration being compiled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to check </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a438a0ba99be29dd5334efec6d001b40d_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a438a0ba99be29dd5334efec6d001b40d_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a438a0ba99be29dd5334efec6d001b40d_icgraph" id="classmemo_1_1_i_allocator_a438a0ba99be29dd5334efec6d001b40d_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_stat_allocator.html#aade440d3b38b571e4c3c4a1d654ae78a" title="This function performs no action. Implements IAllocator::unaligned_dbg_check. The dest allocator is u..." alt="" coords="200,5,355,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a419e6240602d01284e67b38ef6f95911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unaligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates a memory block allocated by unaligned_alloc or unaligned_realloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#ad879010ea7f782337c0f46c8425789ba">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#ad879010ea7f782337c0f46c8425789ba">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#ad879010ea7f782337c0f46c8425789ba">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#ad879010ea7f782337c0f46c8425789ba">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#ad879010ea7f782337c0f46c8425789ba">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a419e6240602d01284e67b38ef6f95911_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a419e6240602d01284e67b38ef6f95911_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a419e6240602d01284e67b38ef6f95911_icgraph" id="classmemo_1_1_i_allocator_a419e6240602d01284e67b38ef6f95911_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#ad879010ea7f782337c0f46c8425789ba" title="memo::DebugAllocator\l::unaligned_free" alt="" coords="161,5,316,46"/><area shape="rect" id="node3" href="classmemo_1_1_region_allocator.html#a1760ceda09f834ec5411bf8e28b85e5e" title="memo::RegionAllocator\l::~RegionAllocator" alt="" coords="160,70,317,111"/><area shape="rect" id="node4" href="classmemo_1_1_stat_allocator.html#ad879010ea7f782337c0f46c8425789ba" title="deallocates a memory block allocated by unaligned_alloc or unaligned_realloc. Implements IAllocator::..." alt="" coords="168,135,309,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a202b96480cec2c2b9df48e81159b62fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* unaligned_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the size of the memory block allocated by unaligned_alloc, possibly moving it in a new location. If the memory block can be resized, the same address is returned. Otherwise the block is allocated in a new location, and the content is copied to the new location. Then the old block is freed. The content of the memory block is preserved up to the lesser of the new size and the old size, while the content of the newly allocated portion is undefined. If the request size is zero the return value is a non-null address that points to a zero-sized memory block. If the reallocation fails nullptr is returned, and the memory block is left unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address of the first byte in the block, or nullptr if the reallocation fails </dd></dl>

<p>Implemented in <a class="el" href="classmemo_1_1_corruption_detector_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c">CorruptionDetectorAllocator</a>, <a class="el" href="classmemo_1_1_debug_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c">DebugAllocator</a>, <a class="el" href="classmemo_1_1_stat_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c">StatAllocator</a>, <a class="el" href="classmemo_1_1_default_allocator.html#adfe2457daa746699a1468f26c9dd02ef">DefaultAllocator</a>, and <a class="el" href="classmemo_1_1_tlsf_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c">TlsfAllocator</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_i_allocator_a202b96480cec2c2b9df48e81159b62fc_icgraph.png" border="0" usemap="#classmemo_1_1_i_allocator_a202b96480cec2c2b9df48e81159b62fc_icgraph" alt=""/></div>
<map name="classmemo_1_1_i_allocator_a202b96480cec2c2b9df48e81159b62fc_icgraph" id="classmemo_1_1_i_allocator_a202b96480cec2c2b9df48e81159b62fc_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_debug_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c" title="memo::DebugAllocator\l::unaligned_realloc" alt="" coords="176,5,331,46"/><area shape="rect" id="node3" href="classmemo_1_1_stat_allocator.html#a1bb6ecb43bdc4d31af49a0761e396c6c" title="changes the size of the memory block allocated by unaligned_alloc. Implements IAllocator::unaligned_r..." alt="" coords="183,70,324,111"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>D:/SmartGit/mmemo/allocators/<a class="el" href="iallocator_8h_source.html">iallocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 30 2014 08:20:39 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
