<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LifoAllocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memo</b></li><li class="navelem"><a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmemo_1_1_lifo_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LifoAllocator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lifo__allocator_8h_source.html">lifo_allocator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator_1_1_test_session.html">TestSession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tester ///  <a href="classmemo_1_1_lifo_allocator_1_1_test_session.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7690239ec6e54f2943dfcb84b4638ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#ac7690239ec6e54f2943dfcb84b4638ef">LifoAllocator</a> ()</td></tr>
<tr class="memdesc:ac7690239ec6e54f2943dfcb84b4638ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocation services ///  <a href="#ac7690239ec6e54f2943dfcb84b4638ef">More...</a><br/></td></tr>
<tr class="separator:ac7690239ec6e54f2943dfcb84b4638ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85696ac6a97f34acf0909013222ecac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#ab85696ac6a97f34acf0909013222ecac">LifoAllocator</a> (void *i_buffer_start_address, size_t i_buffer_length)</td></tr>
<tr class="separator:ab85696ac6a97f34acf0909013222ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4924620b7668d0f7650b7a3402b0e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a5d4924620b7668d0f7650b7a3402b0e9">~LifoAllocator</a> ()</td></tr>
<tr class="separator:a5d4924620b7668d0f7650b7a3402b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533caf6010dac5737ec86226924caac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a3533caf6010dac5737ec86226924caac">set_buffer</a> (void *i_buffer_start_address, size_t i_buffer_length)</td></tr>
<tr class="separator:a3533caf6010dac5737ec86226924caac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a4e46041c37bb67644423a13c80ec5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a92a4e46041c37bb67644423a13c80ec5">alloc</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset)</td></tr>
<tr class="separator:a92a4e46041c37bb67644423a13c80ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08cc55562275ab5a24ad3bffd551aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a1a08cc55562275ab5a24ad3bffd551aa">realloc</a> (void *i_address, size_t i_new_size)</td></tr>
<tr class="separator:a1a08cc55562275ab5a24ad3bffd551aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6b0759afefa3345f8806c0c61ab5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a12f6b0759afefa3345f8806c0c61ab5e">free</a> (void *i_address)</td></tr>
<tr class="separator:a12f6b0759afefa3345f8806c0c61ab5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1edb4c75298ce34740d35b591f084ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#ad1edb4c75298ce34740d35b591f084ca">free_all</a> ()</td></tr>
<tr class="separator:ad1edb4c75298ce34740d35b591f084ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3d785a55f7eedad6b3a4e48410655"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#aa8a3d785a55f7eedad6b3a4e48410655">get_buffer_start</a> () const </td></tr>
<tr class="memdesc:aa8a3d785a55f7eedad6b3a4e48410655"><td class="mdescLeft">&#160;</td><td class="mdescRight">getters ///  <a href="#aa8a3d785a55f7eedad6b3a4e48410655">More...</a><br/></td></tr>
<tr class="separator:aa8a3d785a55f7eedad6b3a4e48410655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd9e8ecab3988a3609f6c7e97e8d541"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#a6cd9e8ecab3988a3609f6c7e97e8d541">get_buffer_size</a> () const </td></tr>
<tr class="separator:a6cd9e8ecab3988a3609f6c7e97e8d541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed215c8c6b91b61727cd14a30a45d5be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#aed215c8c6b91b61727cd14a30a45d5be">get_free_space</a> () const </td></tr>
<tr class="separator:aed215c8c6b91b61727cd14a30a45d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0b34101221dfeedb5d7f9725923b3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_lifo_allocator.html#ade0b34101221dfeedb5d7f9725923b3f">get_used_space</a> () const </td></tr>
<tr class="separator:ade0b34101221dfeedb5d7f9725923b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class implementing LIFO-ordered allocation services. A LIFO allocator provides allocation services with the constrain that only the memory block of top (BOT) can be reallocated or freed. The BOT is the last allocated or resized memory block. After it is freed, the previously allocated block is the new BOT. <a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> is initialized with a memory buffer, which is used to allocate the memory blocks fo the user. If the space remaining in the buffer is not enough to accomplish the alloc or realloc, this class just returns nullptr. <a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> does not provide a deallocation callback, so you have to destroy manually any non-POD object. See also <a class="el" href="classmemo_1_1_object_lifo_allocator.html" title="Class implementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wi...">memo::ObjectLifoAllocator</a>. This class is not thread safe. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac7690239ec6e54f2943dfcb84b4638ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE <a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocation services /// </p>
<p>default constructor. The memory buffer must be assigned before using the <a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> (see set_buffer) </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_lifo_allocator_ac7690239ec6e54f2943dfcb84b4638ef_icgraph.png" border="0" usemap="#classmemo_1_1_lifo_allocator_ac7690239ec6e54f2943dfcb84b4638ef_icgraph" alt=""/></div>
<map name="classmemo_1_1_lifo_allocator_ac7690239ec6e54f2943dfcb84b4638ef_icgraph" id="classmemo_1_1_lifo_allocator_ac7690239ec6e54f2943dfcb84b4638ef_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_lifo_allocator_1_1_test_session.html#a38b088af8017c25c8f43a026cc0d6665" title="test session /// " alt="" coords="147,5,330,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab85696ac6a97f34acf0909013222ecac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE <a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_buffer_start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructor that assigns soon the memory buffer </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_lifo_allocator_ab85696ac6a97f34acf0909013222ecac_cgraph.png" border="0" usemap="#classmemo_1_1_lifo_allocator_ab85696ac6a97f34acf0909013222ecac_cgraph" alt=""/></div>
<map name="classmemo_1_1_lifo_allocator_ab85696ac6a97f34acf0909013222ecac_cgraph" id="classmemo_1_1_lifo_allocator_ab85696ac6a97f34acf0909013222ecac_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_lifo_allocator.html#a3533caf6010dac5737ec86226924caac" title="set_buffer" alt="" coords="147,5,226,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5d4924620b7668d0f7650b7a3402b0e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE ~<a class="el" href="classmemo_1_1_lifo_allocator.html">LifoAllocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>destroys the allocator. All the allocations are freed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92a4e46041c37bb67644423a13c80ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void * alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocates a new memory block, respecting the requested alignment with an offset from the beginning of the block. If the allocation fails nullptr is returned. If the requested size is zero the return value is a non-null address. The content of the newly allocated block is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from beginning of the block of the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

</div>
</div>
<a class="anchor" id="a12f6b0759afefa3345f8806c0c61ab5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deallocates a memory block allocated by alloc or realloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It must be the block on top. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1edb4c75298ce34740d35b591f084ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void free_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resets the allocator, freeing all the allocated memory blocks. </p>

</div>
</div>
<a class="anchor" id="a6cd9e8ecab3988a3609f6c7e97e8d541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the buffer in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a3d785a55f7eedad6b3a4e48410655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE const void * get_buffer_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getters /// </p>
<p>retrieves the beginning of the buffer used to perform allocations. Writing this buffer causes memory corruption. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the beginning if the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="aed215c8c6b91b61727cd14a30a45d5be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_free_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the free portion of the buffer, that is the remaining space. </p>
<dl class="section return"><dt>Returns</dt><dd>free space in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ade0b34101221dfeedb5d7f9725923b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_used_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the used portion of the buffer, that is the allocated space. </p>
<dl class="section return"><dt>Returns</dt><dd>used space in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a1a08cc55562275ab5a24ad3bffd551aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE bool realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>changes the size of the memory block on top of the stack. The content of the memory block is preserved up to the lesser of the new size and the old size, while the content of the newly allocated portion is undefined. The alignment and the offset of the alignment of an existing memory block cannot be changed by realloc. If the reallocation fails false is returned, and the memory block is left unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reallocations succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3533caf6010dac5737ec86226924caac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void set_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_buffer_start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>assigns the memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_buffer_start_address</td><td>pointer to the first byte in the buffer </td></tr>
    <tr><td class="paramname">i_buffer_length</td><td>number of bytes in the buffer </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_lifo_allocator_a3533caf6010dac5737ec86226924caac_icgraph.png" border="0" usemap="#classmemo_1_1_lifo_allocator_a3533caf6010dac5737ec86226924caac_icgraph" alt=""/></div>
<map name="classmemo_1_1_lifo_allocator_a3533caf6010dac5737ec86226924caac_icgraph" id="classmemo_1_1_lifo_allocator_a3533caf6010dac5737ec86226924caac_icgraph">
<area shape="rect" id="node2" href="classmemo_1_1_lifo_allocator.html#ab85696ac6a97f34acf0909013222ecac" title="LifoAllocator" alt="" coords="133,5,227,32"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/SmartGit/mmemo/lifo/<a class="el" href="lifo__allocator_8h_source.html">lifo_allocator.h</a></li>
<li>D:/SmartGit/mmemo/lifo/lifo_allocator.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 08:12:47 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
