<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>TypedPool&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memo</b></li><li class="navelem"><a class="el" href="classmemo_1_1_typed_pool.html">TypedPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmemo_1_1_typed_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TypedPool&lt; TYPE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="typed__pool_8h_source.html">typed_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2ba14bf567887c0285c4e84e7f4f3e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#ae2ba14bf567887c0285c4e84e7f4f3e0">init</a> (size_t i_object_count)</td></tr>
<tr class="separator:ae2ba14bf567887c0285c4e84e7f4f3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa90a5c5c3718da584a64351bf5a8876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#afa90a5c5c3718da584a64351bf5a8876">uninit</a> ()</td></tr>
<tr class="separator:afa90a5c5c3718da584a64351bf5a8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddacbeceb9272d096853a663a432ca7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#a0ddacbeceb9272d096853a663a432ca7">alloc</a> ()</td></tr>
<tr class="separator:a0ddacbeceb9272d096853a663a432ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc17ec687b610a7e2a594cfc664a44"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#a47cc17ec687b610a7e2a594cfc664a44">alloc_slot</a> ()</td></tr>
<tr class="separator:a47cc17ec687b610a7e2a594cfc664a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f79933455057df502c53e84758201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#a5b9f79933455057df502c53e84758201">free</a> (void *i_address)</td></tr>
<tr class="separator:a5b9f79933455057df502c53e84758201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a5f34bc6ce1f0ee0a192375ac34d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#ae0a5f34bc6ce1f0ee0a192375ac34d2b">free_slot</a> (void *i_address)</td></tr>
<tr class="separator:ae0a5f34bc6ce1f0ee0a192375ac34d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158152ac4362355c610847459556a969"><td class="memItemLeft" align="right" valign="top">TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#a158152ac4362355c610847459556a969">create_object</a> ()</td></tr>
<tr class="separator:a158152ac4362355c610847459556a969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0829c8e203675e22c11b5786229abc1"><td class="memItemLeft" align="right" valign="top">TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#af0829c8e203675e22c11b5786229abc1">create_object</a> (const TYPE &amp;i_source)</td></tr>
<tr class="separator:af0829c8e203675e22c11b5786229abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e8b6f76d69e9d3020b9898f8c4924f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_typed_pool.html#ac6e8b6f76d69e9d3020b9898f8c4924f">destroy_object</a> (TYPE *i_object)</td></tr>
<tr class="separator:ac6e8b6f76d69e9d3020b9898f8c4924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TYPE&gt;<br/>
class memo::TypedPool&lt; TYPE &gt;</h3>

<p>Class providing efficient fixed-size allocation services for a specific type. When initialized, the pool allocates a buffer with the default allocator. This buffer is large enough to contain the number of elements specified during the initialization (see <a class="el" href="classmemo_1_1_untyped_pool.html#aac41982807279d7151a8d35b66fc1f50">UntypedPool::init</a>). The pool keeps a linked list of free slots. So both allocations and deallocation are constant time and very fast. There is not space overhead, nor any fragmentation. The only drawback is that the pool must be initialized with a size. When the pool is full, this class can allocate transparently using the default allocator. If you want to use a pool not for a specific type (with the only constraint of the fixed size), you may use <a class="el" href="classmemo_1_1_untyped_pool.html">memo::UntypedPool</a>. This class is not thread safe. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0ddacbeceb9272d096853a663a432ca7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory. The size and the alignment of the block are those of TYPE. If there is not a free sot in the pool, this method allocates using the default allocator. This method allocates a block without constructing any object. You may use the new in-place to construct an object: </p>
<div class="fragment"><div class="line"><span class="keyword">new</span> ( my_pool.alloc() ) MY_TYPE( arg1, arg2 ... )</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>address of the newly allocated block, or nullptr if both the pool and the default allocator could not allocate the block. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_a0ddacbeceb9272d096853a663a432ca7_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_a0ddacbeceb9272d096853a663a432ca7_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_a0ddacbeceb9272d096853a663a432ca7_cgraph" id="classmemo_1_1_typed_pool_a0ddacbeceb9272d096853a663a432ca7_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#ae170032a6c8025dbe9a100661d49d40f" title="memo::UntypedPool::\lalloc" alt="" coords="105,5,253,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a47cc17ec687b610a7e2a594cfc664a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* alloc_slot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory. The size and the alignment of the block are those of TYPE. Unlike <a class="el" href="classmemo_1_1_typed_pool.html#a0ddacbeceb9272d096853a663a432ca7">TypedPool::alloc</a>, this method allocates only in the pool. This method allocates a block without constructing any object. You may use the new in-place to construct an object: </p>
<div class="fragment"><div class="line"><span class="keyword">new</span> ( my_pool.alloc() ) MY_TYPE( arg1, arg2 ... )</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>address of the newly allocated block, or nullptr if the pool could not allocate the block. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_a47cc17ec687b610a7e2a594cfc664a44_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_a47cc17ec687b610a7e2a594cfc664a44_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_a47cc17ec687b610a7e2a594cfc664a44_cgraph" id="classmemo_1_1_typed_pool_a47cc17ec687b610a7e2a594cfc664a44_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#a38aa39bf2c085cb907d821957cd06b81" title="memo::UntypedPool::\lalloc_slot" alt="" coords="131,5,279,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a158152ac4362355c610847459556a969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TYPE* create_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory, and default-construct on object on it. If there is not a free sot in the pool, this method allocates using the default allocator. This method allocates a block constructing the object. Use alloc if you just want to allocate the memory. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new object, or nullptr if both the pool and the default allocator could not allocate the block. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_a158152ac4362355c610847459556a969_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_a158152ac4362355c610847459556a969_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_a158152ac4362355c610847459556a969_cgraph" id="classmemo_1_1_typed_pool_a158152ac4362355c610847459556a969_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#ae170032a6c8025dbe9a100661d49d40f" title="memo::UntypedPool::\lalloc" alt="" coords="155,5,303,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af0829c8e203675e22c11b5786229abc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TYPE* create_object </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory, and copy-construct on object on it. If there is not a free sot in the pool, this method allocates using the default allocator. This method allocates a block constructing the object. Use alloc if you just want to allocate the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new object, or nullptr if both the pool and the default allocator could not allocate the block. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_af0829c8e203675e22c11b5786229abc1_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_af0829c8e203675e22c11b5786229abc1_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_af0829c8e203675e22c11b5786229abc1_cgraph" id="classmemo_1_1_typed_pool_af0829c8e203675e22c11b5786229abc1_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#ae170032a6c8025dbe9a100661d49d40f" title="memo::UntypedPool::\lalloc" alt="" coords="155,5,303,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac6e8b6f76d69e9d3020b9898f8c4924f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_object </td>
          <td>(</td>
          <td class="paramtype">TYPE *&#160;</td>
          <td class="paramname"><em>i_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the specified object and deallocates it. If the block is outside the pool, this method uses the default allocator to free the block. This method calls the destructor of the object. Use free to just deallocate the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_object</td><td>ointer to the object to delete. Can't be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_ac6e8b6f76d69e9d3020b9898f8c4924f_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_ac6e8b6f76d69e9d3020b9898f8c4924f_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_ac6e8b6f76d69e9d3020b9898f8c4924f_cgraph" id="classmemo_1_1_typed_pool_ac6e8b6f76d69e9d3020b9898f8c4924f_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#a86936431ea537e6d0442ddc055cf7693" title="memo::UntypedPool::free" alt="" coords="161,5,330,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5b9f79933455057df502c53e84758201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a block of memory, allocated with alloc or alloc_slot. If the block is outside the pool, this method uses the default allocator to free the block. This method does not call the destructor of the object. Use destroy_object to emulate a full delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_element</td><td>address of the block to free. Can't be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_a5b9f79933455057df502c53e84758201_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_a5b9f79933455057df502c53e84758201_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_a5b9f79933455057df502c53e84758201_cgraph" id="classmemo_1_1_typed_pool_a5b9f79933455057df502c53e84758201_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#a86936431ea537e6d0442ddc055cf7693" title="memo::UntypedPool::free" alt="" coords="97,5,266,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae0a5f34bc6ce1f0ee0a192375ac34d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_slot </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a block of memory, allocated with alloc or alloc_slot. Unlike <a class="el" href="classmemo_1_1_typed_pool.html#a5b9f79933455057df502c53e84758201">TypedPool::free</a>, this method can free only blocks allocated in the pool. Use free_slot only if the block was allocated with alloc_slot. This method does not call the destructor of the object. Use destroy_object to emulate a full delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_element</td><td>address of the block to free. Can't be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_ae0a5f34bc6ce1f0ee0a192375ac34d2b_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_ae0a5f34bc6ce1f0ee0a192375ac34d2b_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_ae0a5f34bc6ce1f0ee0a192375ac34d2b_cgraph" id="classmemo_1_1_typed_pool_ae0a5f34bc6ce1f0ee0a192375ac34d2b_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#a8d5eccc63e8628706fbd2e164ad40d44" title="memo::UntypedPool::\lfree_slot" alt="" coords="126,5,274,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae2ba14bf567887c0285c4e84e7f4f3e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_object_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a buffer with the default allocator, and formats it to be used for fixed size allocations.  i_object_count number of objects in the pool </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer was successfully allocated and formatted, false otherwise </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_ae2ba14bf567887c0285c4e84e7f4f3e0_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_ae2ba14bf567887c0285c4e84e7f4f3e0_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_ae2ba14bf567887c0285c4e84e7f4f3e0_cgraph" id="classmemo_1_1_typed_pool_ae2ba14bf567887c0285c4e84e7f4f3e0_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#aac41982807279d7151a8d35b66fc1f50" title="memo::UntypedPool::init" alt="" coords="93,45,259,72"/><area shape="rect" id="node3" href="classmemo_1_1_untyped_pool.html#afa90a5c5c3718da584a64351bf5a8876" title="memo::UntypedPool::\luninit" alt="" coords="311,5,459,46"/><area shape="rect" id="node5" href="classmemo_1_1_default_allocator.html#aa0efeca40d5326beeff035039fe5cc36" title="allocates an aligned memory block. Implements IAllocator::alloc. ::malloc is used to allocate the mem..." alt="" coords="307,70,464,111"/><area shape="rect" id="node4" href="classmemo_1_1_default_allocator.html#a5b9f79933455057df502c53e84758201" title="deallocates a memory block allocated by alloc or realloc. Implements IAllocator::free. ::free is used to deallocate the memory block. " alt="" coords="512,5,669,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afa90a5c5c3718da584a64351bf5a8876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uninit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates the buffer used by the pool. This method should be called only when there are no living blocks allocated by the pool. It's legal to call this method before init or twice. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmemo_1_1_typed_pool_afa90a5c5c3718da584a64351bf5a8876_cgraph.png" border="0" usemap="#classmemo_1_1_typed_pool_afa90a5c5c3718da584a64351bf5a8876_cgraph" alt=""/></div>
<map name="classmemo_1_1_typed_pool_afa90a5c5c3718da584a64351bf5a8876_cgraph" id="classmemo_1_1_typed_pool_afa90a5c5c3718da584a64351bf5a8876_cgraph">
<area shape="rect" id="node2" href="classmemo_1_1_untyped_pool.html#afa90a5c5c3718da584a64351bf5a8876" title="memo::UntypedPool::\luninit" alt="" coords="107,5,255,46"/><area shape="rect" id="node3" href="classmemo_1_1_default_allocator.html#a5b9f79933455057df502c53e84758201" title="deallocates a memory block allocated by alloc or realloc. Implements IAllocator::free. ::free is used to deallocate the memory block. " alt="" coords="304,5,461,46"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/SmartGit/mmemo/pool/<a class="el" href="typed__pool_8h_source.html">typed_pool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 23 2014 08:06:00 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
