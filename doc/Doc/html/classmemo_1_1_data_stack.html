<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>DataStack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="memo_logo.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memo</b></li><li class="navelem"><a class="el" href="classmemo_1_1_data_stack.html">DataStack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmemo_1_1_data_stack-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataStack Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services with the constrain that only the memory block of top (BOT) can be reallocated or freed. The BOT is the last allocated or resized memory block. After it is freed, the previously allocated block is the new BOT. <a class="el" href="classmemo_1_1_data_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">DataStack</a> is initialized with a memory buffer, which is used to allocate the memory blocks fo the user. If the space remaining in the buffer is not enough to accomplish the alloc or realloc, this class just returns nullptr. <a class="el" href="classmemo_1_1_data_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">DataStack</a> does not provide a deallocation callback, so you have to destroy manually any non-POD object. See also <a class="el" href="classmemo_1_1_object_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">memo::ObjectStack</a>. This class is not thread safe.  
 <a href="classmemo_1_1_data_stack.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="data__stack_8h_source.html">data_stack.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack_1_1_test_session.html">TestSession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tester ///  <a href="classmemo_1_1_data_stack_1_1_test_session.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77539065c72f0aaec70a7d83a68c6b02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a77539065c72f0aaec70a7d83a68c6b02">DataStack</a> ()</td></tr>
<tr class="memdesc:a77539065c72f0aaec70a7d83a68c6b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocation services ///  <a href="#a77539065c72f0aaec70a7d83a68c6b02">More...</a><br/></td></tr>
<tr class="separator:a77539065c72f0aaec70a7d83a68c6b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafe5eff5caea302e8113d79aae6ee53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#abafe5eff5caea302e8113d79aae6ee53">DataStack</a> (void *i_buffer_start_address, size_t i_buffer_length)</td></tr>
<tr class="separator:abafe5eff5caea302e8113d79aae6ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d46674a3d0dba304fbdf7d5a4221a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a953d46674a3d0dba304fbdf7d5a4221a">~DataStack</a> ()</td></tr>
<tr class="separator:a953d46674a3d0dba304fbdf7d5a4221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533caf6010dac5737ec86226924caac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a3533caf6010dac5737ec86226924caac">set_buffer</a> (void *i_buffer_start_address, size_t i_buffer_length)</td></tr>
<tr class="separator:a3533caf6010dac5737ec86226924caac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a4e46041c37bb67644423a13c80ec5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a92a4e46041c37bb67644423a13c80ec5">alloc</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset)</td></tr>
<tr class="separator:a92a4e46041c37bb67644423a13c80ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08cc55562275ab5a24ad3bffd551aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a1a08cc55562275ab5a24ad3bffd551aa">realloc</a> (void *i_address, size_t i_new_size)</td></tr>
<tr class="separator:a1a08cc55562275ab5a24ad3bffd551aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6b0759afefa3345f8806c0c61ab5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a12f6b0759afefa3345f8806c0c61ab5e">free</a> (void *i_address)</td></tr>
<tr class="separator:a12f6b0759afefa3345f8806c0c61ab5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1edb4c75298ce34740d35b591f084ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#ad1edb4c75298ce34740d35b591f084ca">free_all</a> ()</td></tr>
<tr class="separator:ad1edb4c75298ce34740d35b591f084ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3d785a55f7eedad6b3a4e48410655"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#aa8a3d785a55f7eedad6b3a4e48410655">get_buffer_start</a> () const </td></tr>
<tr class="memdesc:aa8a3d785a55f7eedad6b3a4e48410655"><td class="mdescLeft">&#160;</td><td class="mdescRight">getters ///  <a href="#aa8a3d785a55f7eedad6b3a4e48410655">More...</a><br/></td></tr>
<tr class="separator:aa8a3d785a55f7eedad6b3a4e48410655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd9e8ecab3988a3609f6c7e97e8d541"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#a6cd9e8ecab3988a3609f6c7e97e8d541">get_buffer_size</a> () const </td></tr>
<tr class="separator:a6cd9e8ecab3988a3609f6c7e97e8d541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed215c8c6b91b61727cd14a30a45d5be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#aed215c8c6b91b61727cd14a30a45d5be">get_free_space</a> () const </td></tr>
<tr class="separator:aed215c8c6b91b61727cd14a30a45d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0b34101221dfeedb5d7f9725923b3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemo_1_1_data_stack.html#ade0b34101221dfeedb5d7f9725923b3f">get_used_space</a> () const </td></tr>
<tr class="separator:ade0b34101221dfeedb5d7f9725923b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services with the constrain that only the memory block of top (BOT) can be reallocated or freed. The BOT is the last allocated or resized memory block. After it is freed, the previously allocated block is the new BOT. <a class="el" href="classmemo_1_1_data_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">DataStack</a> is initialized with a memory buffer, which is used to allocate the memory blocks fo the user. If the space remaining in the buffer is not enough to accomplish the alloc or realloc, this class just returns nullptr. <a class="el" href="classmemo_1_1_data_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">DataStack</a> does not provide a deallocation callback, so you have to destroy manually any non-POD object. See also <a class="el" href="classmemo_1_1_object_stack.html" title="Class impementing LIFO-ordered allocation services. A LIFO allocator provides allocation services wit...">memo::ObjectStack</a>. This class is not thread safe. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a77539065c72f0aaec70a7d83a68c6b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE <a class="el" href="classmemo_1_1_data_stack.html">DataStack</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocation services /// </p>
<p>default constructor. The memory buffer must be assigned before using the allocator (see set_buffer) </p>

</div>
</div>
<a class="anchor" id="abafe5eff5caea302e8113d79aae6ee53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE <a class="el" href="classmemo_1_1_data_stack.html">DataStack</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_buffer_start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructor that assigns soon the memory buffer </p>

</div>
</div>
<a class="anchor" id="a953d46674a3d0dba304fbdf7d5a4221a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE ~<a class="el" href="classmemo_1_1_data_stack.html">DataStack</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>destroys the allocator. All the allocations are freed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92a4e46041c37bb67644423a13c80ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void * alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocates a new memory block, respecting the requested alignment with an offset from the beginning of the block. If the allocation fails nullptr is returned. If the requested size is zero the return value is a non-null address. The content of the newly allocated block is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the block in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment requested for the block. It must be an integer power of 2 </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset from beginning of the block of the address that respects the alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the first byte in the block, or nullptr if the allocation fails </dd></dl>

</div>
</div>
<a class="anchor" id="a12f6b0759afefa3345f8806c0c61ab5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deallocates a memory block allocated by alloc or realloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to free. It must be the block on top. It cannot be nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1edb4c75298ce34740d35b591f084ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void free_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resets the allocator, freeing all the allocated memory blocks. </p>

</div>
</div>
<a class="anchor" id="a6cd9e8ecab3988a3609f6c7e97e8d541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the buffer in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a3d785a55f7eedad6b3a4e48410655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE const void * get_buffer_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getters /// </p>
<p>retrieves the beginning of the buffer used to perform allocations. Writing this buffer causes memory corruption. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the beginning if the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="aed215c8c6b91b61727cd14a30a45d5be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_free_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the free portion of the buffer, that is the remaining space. </p>
<dl class="section return"><dt>Returns</dt><dd>free space in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ade0b34101221dfeedb5d7f9725923b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE size_t get_used_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>retrieves the size of the used portion of the buffer, that is the allocated space. </p>
<dl class="section return"><dt>Returns</dt><dd>used space in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a1a08cc55562275ab5a24ad3bffd551aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE bool realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>changes the size of the memory block on top of the stack. The content of the memory block is preserved up to the lesser of the new size and the old size, while the content of the newly allocated portion is undefined. The alignment and the offset of the alignment of an existing memory block cannot be changed by realloc. If the reallocation fails false is returned, and the memory block is left unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_address</td><td>address of the memory block to reallocate. This parameter cannot be nullptr. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>new size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reallocations succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3533caf6010dac5737ec86226924caac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMO_INLINE void set_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_buffer_start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>assigns the memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_buffer_start_address</td><td>pointer to the first byte in the buffer </td></tr>
    <tr><td class="paramname">i_buffer_length</td><td>number of bytes in the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/GitHub/mmemo/lifo/<a class="el" href="data__stack_8h_source.html">data_stack.h</a></li>
<li>D:/GitHub/mmemo/lifo/data_stack.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 14 2013 16:16:37 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
